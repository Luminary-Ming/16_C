/*
	野指针 : 指针指向一个已被删除对象或者已释放空间的地址
*/
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	int *p = NULL;

	p = malloc(sizeof(int));  // 开辟 4 字节的堆区空间
	if (p == NULL)  // 判断是否开辟失败
	{
        printf("开辟空间失败!\n");  //打印错误信息
        return -1;  // 由于开辟空间失败, 结束程序, 并且返回 -1
	}

    *p = 9527;

    printf("free 之前  p = %p\n", p);  // free 之前  p = 0x5555555592a0
    printf("free 之前 *p = %d\n", *p);  // free 之前 *p = 9527

    free(p);  // 释放开辟的空间 (只释放内存，不改变指针的值)

    printf("free 之后  p = %p\n", p);  // free 之后  p = 0x5555555592a0
    printf("free 之后 *p = %d\n", *p);  // free 之后 *p = 1431655769


    *p = 6666;  // 使用野指针写入已释放的内存

    printf("最后  p = %p\n", p);  // 最后  p = 0x5555555592a0
    printf("最后 *p = %d\n", *p);  // 最后 *p = 6666
}
/*
    free 之后 *p = 1431655769

    这个值 1431655769 是十六进制的 0x55555555
    这是内存释放后被填充的标记值
    在调试模式下，许多内存分配器会用特殊值填充已释放内存（如 0x55555555 或 0xdeadbeef）


    为什么输出会这样？
    释放前：地址 0x5555555592a0: [9527] ← 你的数据
    释放后：地址 0x5555555592a0: [0x55555555] ← 内存分配器的标记


    为什么不能使用野指针 :

    内存已被释放，属于系统内存池
    可能已经被其他 malloc() 调用重新分配
    你可能正在破坏其他变量的数据

    野指针的危险性 :  可能引发程序崩溃、数据损坏或安全漏洞。
*/